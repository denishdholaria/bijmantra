"""Generate markdown API docs by statically scanning FastAPI route declarations."""

from __future__ import annotations

import datetime as dt
import json
import re
from pathlib import Path
from typing import Any


ROOT = Path(__file__).resolve().parents[3]
BACKEND_APP = ROOT / "backend" / "app"
DOC_PATH = ROOT / "docs" / "api" / "AUTOGEN_SPEC.md"
SPEC_SNAPSHOT_PATH = ROOT / "docs" / "api" / "AUTOGEN_SPEC.snapshot.json"


def _extract_routes() -> list[dict[str, Any]]:
    routes: list[dict[str, Any]] = []
    pattern = re.compile(r'@(?:\w+\.)?(get|post|put|patch|delete|options)\(\s*["\']([^"\']+)["\']')
    for py_file in BACKEND_APP.rglob("*.py"):
        text = py_file.read_text(encoding="utf-8", errors="ignore")
        rel_source = str(py_file.relative_to(ROOT))
        for method_raw, raw_path in pattern.findall(text):
            method = method_raw.upper()
            path = raw_path
            if not path.startswith("/"):
                path = "/" + path
            if rel_source.startswith("backend/app/api/brapi/") or rel_source.startswith(
                "backend/app/api/v2/core/"
            ):
                if not path.startswith("/brapi/v2"):
                    path = "/brapi/v2" + path
            elif rel_source.startswith("backend/app/api/v2/") and not path.startswith("/api/v2") and not path.startswith("/brapi/v2"):
                path = "/api/v2" + path
            routes.append(
                {
                    "method": method,
                    "path": path,
                    "summary": "",
                    "source": rel_source,
                }
            )
    return sorted(routes, key=lambda item: (item["path"], item["method"]))


def _extract_models() -> list[str]:
    models: set[str] = set()
    for py_file in (BACKEND_APP / "schemas").rglob("*.py"):
        text = py_file.read_text(encoding="utf-8", errors="ignore")
        for line in text.splitlines():
            if line.strip().startswith("class ") and "BaseModel" in line:
                models.add(line.split("class ", 1)[1].split("(", 1)[0].strip())
    return sorted(models)


def build_markdown(spec: dict[str, Any]) -> str:
    routes = spec["routes"]
    models = spec["models"]
    lines = [
        "# AUTOGENERATED API SPEC",
        "",
        f"Generated: {dt.datetime.utcnow().isoformat()}Z",
        "",
        f"Total operations: **{len(routes)}**",
        f"Total models: **{len(models)}**",
        "",
        "## Routes",
        "",
        "| Method | Path | Description | Source |",
        "|---|---|---|---|",
    ]
    for route in routes:
        lines.append(
            f"| `{route['method']}` | `{route['path']}` | {route['summary'] or '-'} | `{route['source']}` |"
        )

    lines.extend(["", "## Models", ""])
    lines.extend(f"- `{model}`" for model in models)
    return "\n".join(lines) + "\n"


def main() -> int:
    spec = {"routes": _extract_routes(), "models": _extract_models()}
    markdown = build_markdown(spec)

    DOC_PATH.parent.mkdir(parents=True, exist_ok=True)
    DOC_PATH.write_text(markdown, encoding="utf-8")
    SPEC_SNAPSHOT_PATH.write_text(json.dumps(spec, indent=2), encoding="utf-8")
    print(f"Generated {DOC_PATH}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
